# macOSç‰ˆæœ¬
é’ˆå¯¹ **macOS ç‰ˆæœ¬**ã€**å¤§é‡ç¬”è®°**ã€**å•æ¡ç¬”è®°å­—æ•°å¤šï¼ˆ1000å­—+ï¼‰**ã€**éå¸¸çœ‹é‡æ€§èƒ½** çš„åœºæ™¯ï¼Œæˆ‘æ¨èä»¥ä¸‹æ–¹æ¡ˆï¼Œå¹¶è¯¦ç»†è¯´æ˜åŸå› å’Œå®ç°æ­¥éª¤ï¼š

---

## âœ… æ¨èæ–¹æ¡ˆï¼šNSCollectionView + è‡ªå®šä¹‰ç€‘å¸ƒæµ Layout + NSViewControllerRepresentable

### æ ¸å¿ƒç†ç”±
- **macOS æœ€é«˜æ€§èƒ½çš„åˆ—è¡¨/ç½‘æ ¼ç»„ä»¶**ï¼š`NSCollectionView` æ˜¯ macOS ä¸Šæœ€æˆç†Ÿçš„è§†å›¾å®¹å™¨ï¼Œæ”¯æŒï¼š
  - **è§†å›¾å¤ç”¨ï¼ˆItem Recyclingï¼‰**ï¼šé¿å…å¤§é‡è§†å›¾åŒæ—¶å­˜åœ¨å†…å­˜ä¸­ã€‚
  - **æ‡’åŠ è½½ï¼ˆLazy Loadingï¼‰**ï¼šåªæ¸²æŸ“å¯è§åŒºåŸŸï¼Œæ»šåŠ¨æ—¶åŠ¨æ€åŠ è½½å’Œå›æ”¶ã€‚
  - **é«˜åº¦ç¼“å­˜æœºåˆ¶**ï¼šå¯è‡ªå®šä¹‰å¹¶ç¼“å­˜æ¯ä¸ª item çš„é«˜åº¦ï¼Œé¿å…é‡å¤è®¡ç®—é•¿æ–‡æœ¬å¸ƒå±€ã€‚
- **ç€‘å¸ƒæµæˆç†Ÿæ€è·¯**ï¼šé€šè¿‡è‡ªå®šä¹‰ `NSCollectionViewLayout` å®ç°ç€‘å¸ƒæµå¸ƒå±€ï¼Œå‚è€ƒ iOS ä¸Šæˆç†Ÿçš„ç€‘å¸ƒæµç®—æ³•ï¼ˆå¦‚ `CHTCollectionViewWaterfallLayout`ï¼‰ã€‚
- **ä¸ SwiftUI æ— ç¼é›†æˆ**ï¼šé€šè¿‡ `NSViewControllerRepresentable` å°† `NSCollectionView` åµŒå…¥ SwiftUIï¼Œæ—¢èƒ½ç”¨ SwiftUI ç”Ÿæ€ï¼Œåˆèƒ½è·å¾— `NSCollectionView` çš„æ€§èƒ½ã€‚

---

## ğŸš€ å…³é”®å®ç°æ­¥éª¤

### 1. è‡ªå®šä¹‰ç€‘å¸ƒæµ Layoutï¼ˆç»§æ‰¿è‡ª NSCollectionViewLayoutï¼‰
```swift
import AppKit

class WaterfallLayout: NSCollectionViewLayout {
    // å¸ƒå±€å±æ€§
    var columnCount = 2
    var itemSpacing: CGFloat = 10
    var lineSpacing: CGFloat = 10
    private var layoutAttributes: [NSCollectionViewLayoutAttributes] = []
    private var columnHeights: [CGFloat] = []
    private var contentSize: CGSize = .zero

    override func prepare() {
        super.prepare()
        
        guard let collectionView = collectionView else { return }
        
        // åˆå§‹åŒ–åˆ—é«˜
        columnHeights = Array(repeating: 0, count: columnCount)
        layoutAttributes.removeAll()
        
        // è®¡ç®—æ¯ä¸ª item çš„å¸ƒå±€å±æ€§
        let itemWidth = (collectionView.bounds.width - CGFloat(columnCount - 1) * itemSpacing) / CGFloat(columnCount)
        
        for section in 0..<collectionView.numberOfSections {
            for item in 0..<collectionView.numberOfItems(inSection: section) {
                let indexPath = IndexPath(item: item, section: section)
                let attributes = NSCollectionViewLayoutAttributes(forItemWith: indexPath)
                
                // æ‰¾åˆ°æœ€çŸ­çš„åˆ—
                let shortestColumn = columnHeights.enumerated().min { $0.element < $1.element }?.offset ?? 0
                
                // è®¡ç®— frame
                let x = CGFloat(shortestColumn) * (itemWidth + itemSpacing)
                let y = columnHeights[shortestColumn]
                
                // è·å– item é«˜åº¦ï¼ˆéœ€ä»æ•°æ®æºè·å–ï¼Œå»ºè®®ç¼“å­˜ï¼‰
                let itemHeight = collectionView.dataSource?.collectionView?(collectionView, layout: self, sizeForItemAt: indexPath)?.height ?? 100
                
                attributes.frame = CGRect(x: x, y: y, width: itemWidth, height: itemHeight)
                layoutAttributes.append(attributes)
                
                // æ›´æ–°åˆ—é«˜
                columnHeights[shortestColumn] += itemHeight + lineSpacing
            }
        }
        
        // è®¡ç®—å†…å®¹å°ºå¯¸
        contentSize = CGSize(width: collectionView.bounds.width, height: columnHeights.max() ?? 0)
    }

    override func layoutAttributesForElements(in rect: CGRect) -> [NSCollectionViewLayoutAttributes] {
        return layoutAttributes.filter { rect.intersects($0.frame) }
    }

    override func layoutAttributesForItem(at indexPath: IndexPath) -> NSCollectionViewLayoutAttributes? {
        return layoutAttributes.first { $0.indexPath == indexPath }
    }

    override var collectionViewContentSize: CGSize {
        return contentSize
    }
}
```

### 2. å°è£… NSCollectionView ä¸º SwiftUI å¯ç”¨ç»„ä»¶
```swift
import SwiftUI
import AppKit

struct MacWaterfallView: NSViewControllerRepresentable {
    var items: [NoteItem]

    func makeNSViewController(context: Context) -> NSViewController {
        let viewController = NSViewController()
        let scrollView = NSScrollView()
        let collectionView = NSCollectionView()
        
        // é…ç½® ScrollView
        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = false
        scrollView.autohidesScrollers = false
        
        // é…ç½® CollectionView
        collectionView.collectionViewLayout = WaterfallLayout()
        collectionView.isSelectable = true
        collectionView.backgroundColor = NSColor.controlBackgroundColor
        
        // æ³¨å†Œ Item
        collectionView.register(NoteItem.self, forItemWithIdentifier: NSUserInterfaceItemIdentifier("NoteItem"))
        
        // è®¾ç½®æ•°æ®æºå’Œä»£ç†
        collectionView.dataSource = context.coordinator
        collectionView.delegate = context.coordinator
        
        // åµŒå…¥è§†å›¾å±‚çº§
        scrollView.documentView = collectionView
        viewController.view = scrollView
        
        return viewController
    }

    func updateNSViewController(_ nsViewController: NSViewController, context: Context) {
        context.coordinator.items = items
        if let collectionView = (nsViewController.view as? NSScrollView)?.documentView as? NSCollectionView {
            collectionView.reloadData()
        }
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, NSCollectionViewDataSource, NSCollectionViewDelegate, WaterfallLayoutDelegate {
        var parent: MacWaterfallView
        var items: [NoteItem]
        private var heightCache: [String: CGFloat] = [:]

        init(_ parent: MacWaterfallView) {
            self.parent = parent
            self.items = parent.items
        }

        func numberOfSections(in collectionView: NSCollectionView) -> Int {
            return 1
        }

        func collectionView(_ collectionView: NSCollectionView, numberOfItemsInSection section: Int) -> Int {
            return items.count
        }

        func collectionView(_ collectionView: NSCollectionView, itemForRepresentedObjectAt indexPath: IndexPath) -> NSCollectionViewItem {
            let item = collectionView.makeItem(withIdentifier: NSUserInterfaceItemIdentifier("NoteItem"), for: indexPath)
            if let noteItem = item as? NoteItem {
                let note = items[indexPath.item]
                noteItem.configure(with: note)
            }
            return item
        }

        // ç€‘å¸ƒæµé«˜åº¦å›è°ƒï¼ˆå¸¦ç¼“å­˜ï¼‰
        func collectionView(_ collectionView: NSCollectionView, layout: WaterfallLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
            let note = items[indexPath.item]
            let key = "\(note.id)"
            
            if let cachedHeight = heightCache[key] {
                return CGSize(width: collectionView.bounds.width / 2 - 10, height: cachedHeight)
            }
            
            let height = calculateHeight(for: note.content, width: collectionView.bounds.width / 2 - 20)
            heightCache[key] = height
            return CGSize(width: collectionView.bounds.width / 2 - 10, height: height)
        }

        private func calculateHeight(for text: String, width: CGFloat) -> CGFloat {
            let font = NSFont.systemFont(ofSize: 16)
            let textStorage = NSTextStorage(string: text)
            let textContainer = NSTextContainer(size: CGSize(width: width, height: .greatestFiniteDimension))
            let layoutManager = NSLayoutManager()
            
            layoutManager.addTextContainer(textContainer)
            textStorage.addLayoutManager(layoutManager)
            textStorage.addAttribute(.font, value: font, range: NSRange(location: 0, length: text.count))
            
            textContainer.lineBreakMode = .byWordWrapping
            layoutManager.ensureLayout(for: textContainer)
            
            let boundingRect = layoutManager.usedRect(for: textContainer)
            return ceil(boundingRect.height) + 40 // åŠ ä¸Š padding
        }
    }
}

// è‡ªå®šä¹‰ NSCollectionViewItem
class NoteItem: NSCollectionViewItem {
    private let textField = NSTextField()

    override func loadView() {
        view = NSView()
        
        textField.isEditable = false
        textField.isBordered = false
        textField.backgroundColor = .clear
        textField.font = NSFont.systemFont(ofSize: 16)
        textField.lineBreakMode = .byWordWrapping
        
        view.addSubview(textField)
        textField.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            textField.topAnchor.constraint(equalTo: view.topAnchor, constant: 10),
            textField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 10),
            textField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -10),
            textField.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -10)
        ])
    }

    func configure(with note: NoteItem) {
        textField.stringValue = note.content
    }
}
```

### 3. åœ¨ SwiftUI ä¸­ä½¿ç”¨
```swift
struct ContentView: View {
    @State private var notes: [NoteItem] = []

    var body: some View {
        MacWaterfallView(items: notes)
            .onAppear {
                loadNotes()
            }
    }

    private func loadNotes() {
        // æ¨¡æ‹ŸåŠ è½½å¤§é‡æ•°æ®
        notes = (0..<1000).map { index in
            NoteItem(content: "è¿™æ˜¯ç¬¬ \(index) æ¡ç¬”è®°ï¼Œå†…å®¹å¾ˆé•¿..." + String(repeating: "æµ‹è¯•æ–‡æœ¬", count: 100))
        }
    }
}

struct NoteItem: Identifiable {
    var id = UUID()
    var content: String
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

### 1. é«˜åº¦ç¼“å­˜
- åœ¨ `Coordinator` ä¸­ä½¿ç”¨ `heightCache` å­—å…¸ç¼“å­˜æ¯ä¸ª item çš„é«˜åº¦ï¼Œé¿å…é‡å¤è®¡ç®—é•¿æ–‡æœ¬å¸ƒå±€ã€‚
- ä½¿ç”¨ `NSTextStorage` + `NSLayoutManager` ç²¾ç¡®è®¡ç®—æ–‡æœ¬é«˜åº¦ã€‚

### 2. è§†å›¾å¤ç”¨
- `NSCollectionView` é»˜è®¤æ”¯æŒ item å¤ç”¨ï¼Œç¡®ä¿ `makeItem(withIdentifier:for:)` æ­£ç¡®å®ç°ã€‚
- é¿å…åœ¨ `NoteItem` ä¸­åˆ›å»ºå¤§é‡å­è§†å›¾ï¼Œä¿æŒè§†å›¾å±‚çº§ç®€å•ã€‚

### 3. åˆ†é¡µåŠ è½½ï¼ˆPaginationï¼‰
- ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼Œæ»šåŠ¨åˆ°åº•éƒ¨æ—¶åŠ è½½æ›´å¤šæ•°æ®ï¼š
```swift
func scrollViewDidScroll(_ scrollView: NSScrollView) {
    let visibleRect = scrollView.contentView.visibleRect
    let contentHeight = scrollView.documentView?.bounds.height ?? 0
    let scrollPosition = visibleRect.maxY
    
    if scrollPosition > contentHeight - 100 {
        // è§¦å‘åŠ è½½æ›´å¤š
        loadMoreNotes()
    }
}
```

### 4. å¼‚æ­¥æ¸²æŸ“
- é•¿æ–‡æœ¬å¸ƒå±€è®¡ç®—æ”¾åˆ°åå°é˜Ÿåˆ—ï¼Œé¿å…ä¸»çº¿ç¨‹å¡é¡¿ï¼š
```swift
private func calculateHeight(for text: String, width: CGFloat) -> CGFloat {
    return DispatchQueue.main.sync {
        // è®¡ç®—é€»è¾‘...
    }
}
```

---

## ğŸš« ä¸æ¨èçº¯ SwiftUI æ–¹æ¡ˆçš„åŸå› 

| æ–¹æ¡ˆ                | æ€§èƒ½ç“¶é¢ˆè¯´æ˜                                                                 |
|---------------------|----------------------------------------------------------------------------|
| ç¬¬ä¸‰æ–¹åº“ï¼ˆWaterfallGrid/MasonryStackï¼‰ | æ— è§†å›¾å¤ç”¨ï¼Œå¤§æ•°æ®é‡ä¸‹å†…å­˜å ç”¨é«˜ï¼›é•¿æ–‡æœ¬é«˜åº¦è®¡ç®—é¢‘ç¹ï¼Œæ˜“å¡é¡¿ã€‚               |
| LazyVStack+HStackç»„åˆ | è™½æœ‰æ‡’åŠ è½½ï¼Œä½†ç€‘å¸ƒæµéœ€æ‰‹åŠ¨ç®¡ç†åˆ—é«˜ï¼Œä¸” SwiftUI åœ¨ macOS ä¸Šé•¿æ–‡æœ¬å¸ƒå±€æ€§èƒ½ä¸å¦‚ NSCollectionViewã€‚ |
| è‡ªå®šä¹‰ Layout åè®®   | è™½ç„¶çµæ´»ï¼Œä½†éœ€è‡ªè¡Œå®ç°æ‡’åŠ è½½ã€è§†å›¾å¤ç”¨ã€é«˜åº¦ç¼“å­˜ï¼Œå·¥ç¨‹é‡å¤§ï¼Œä¸”ä»ä¸å¦‚ NSCollectionView æˆç†Ÿã€‚ |

---

## ğŸ¯ æ€»ç»“

- **æœ€ä½³é€‰æ‹©**ï¼š**NSCollectionView + è‡ªå®šä¹‰ç€‘å¸ƒæµ Layout + NSViewControllerRepresentable**ï¼Œå…¼é¡¾æ€§èƒ½å’Œæˆç†Ÿåº¦ã€‚
- **ä¼˜åŒ–é‡ç‚¹**ï¼šé«˜åº¦ç¼“å­˜ã€è§†å›¾å¤ç”¨ã€åˆ†é¡µåŠ è½½ã€å¼‚æ­¥æ¸²æŸ“ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼šè¶…å¤§æ•°æ®é‡ï¼ˆä¸Šåƒæ¡ç¬”è®°ï¼‰ã€é•¿æ–‡æœ¬ï¼ˆ1000å­—+ï¼‰ã€é«˜åˆ·æ–°é¢‘ç‡ã€è¦æ±‚æè‡´æ»šåŠ¨æµç•…åº¦ã€‚

å¦‚éœ€å…·ä½“ä»£ç ç¤ºä¾‹ã€åˆ†é¡µåŠ è½½ç»†èŠ‚æˆ–é«˜åº¦ç¼“å­˜å®ç°ï¼Œå¯è¿›ä¸€æ­¥æ·±å…¥æ¢è®¨ï¼


# iOSç‰ˆæœ¬

é’ˆå¯¹ä½ çš„åœºæ™¯â€”â€”**ç¬”è®°æ•°é‡å¾ˆå¤šã€å•æ¡ç¬”è®°å­—æ•°å¯èƒ½é«˜è¾¾1000å­—ã€éå¸¸çœ‹é‡æ€§èƒ½**â€”â€”æˆ‘å¼ºçƒˆæ¨èä»¥ä¸‹æ–¹æ¡ˆï¼Œå¹¶ä»æ€§èƒ½è§’åº¦è¯¦ç»†åˆ†æï¼š

---

## âœ… æ¨èæ–¹æ¡ˆï¼šUICollectionView + ç€‘å¸ƒæµLayout + UIViewControllerRepresentable

### æ ¸å¿ƒç†ç”±
- **æè‡´æ€§èƒ½**ï¼šUICollectionView æ˜¯ iOS ä¸Šæœ€æˆç†Ÿçš„åˆ—è¡¨/ç½‘æ ¼è§†å›¾ç»„ä»¶ï¼Œè‡ªå¸¦ï¼š
  - **è§†å›¾å¤ç”¨ï¼ˆCell Recyclingï¼‰**ï¼šé¿å…å¤§é‡è§†å›¾åŒæ—¶å­˜åœ¨å†…å­˜ä¸­ã€‚
  - **æ‡’åŠ è½½ï¼ˆLazy Loadingï¼‰**ï¼šåªæ¸²æŸ“å¯è§åŒºåŸŸï¼Œæ»šåŠ¨æ—¶åŠ¨æ€åŠ è½½å’Œå›æ”¶ã€‚
  - **é«˜åº¦ç¼“å­˜æœºåˆ¶**ï¼šå¯è‡ªå®šä¹‰å¹¶ç¼“å­˜æ¯ä¸ªcellçš„é«˜åº¦ï¼Œé¿å…é‡å¤è®¡ç®—é•¿æ–‡æœ¬å¸ƒå±€ã€‚
- **ç€‘å¸ƒæµæˆç†Ÿæ–¹æ¡ˆ**ï¼šæœ‰å¤§é‡æˆç†Ÿçš„ç¬¬ä¸‰æ–¹ç€‘å¸ƒæµLayoutï¼ˆå¦‚ `CHTCollectionViewWaterfallLayout`ï¼‰ï¼Œæ”¯æŒåŠ¨æ€é«˜åº¦ã€å¤šåˆ—ã€æ»šåŠ¨ä¼˜åŒ–ç­‰ã€‚
- **ä¸ SwiftUI æ— ç¼é›†æˆ**ï¼šé€šè¿‡ `UIViewControllerRepresentable` å°† UICollectionView åµŒå…¥ SwiftUIï¼Œæ—¢èƒ½ç”¨ SwiftUI ç”Ÿæ€ï¼Œåˆèƒ½è·å¾— UICollectionView çš„æ€§èƒ½ã€‚

---

## ğŸš€ å…³é”®å®ç°æ­¥éª¤

### 1. å¼•å…¥ç€‘å¸ƒæµLayoutåº“
æ¨èä½¿ç”¨ [CHTCollectionViewWaterfallLayout](https://github.com/chiahsien/CHTCollectionViewWaterfallLayout)ï¼ˆObjective-Cï¼Œä½†å…¼å®¹Swiftï¼‰æˆ–åŒç±»Swiftåº“ã€‚

```swift
// Podfile
pod 'CHTCollectionViewWaterfallLayout'
```

### 2. å°è£… UICollectionView ä¸º SwiftUI å¯ç”¨ç»„ä»¶
ä½¿ç”¨ `UIViewControllerRepresentable` å’Œ `UICollectionViewController`ï¼Œå°è£…ç€‘å¸ƒæµè§†å›¾ã€‚

```swift
import SwiftUI
import UIKit
import CHTCollectionViewWaterfallLayout

struct WaterfallView: UIViewControllerRepresentable {
    var items: [NoteItem] // ä½ çš„ç¬”è®°æ•°æ®æ¨¡å‹

    func makeUIViewController(context: Context) -> UICollectionViewController {
        let layout = CHTCollectionViewWaterfallLayout()
        layout.columnCount = 2 // åˆ—æ•°
        layout.minimumColumnSpacing = 10 // åˆ—é—´è·
        layout.minimumInteritemSpacing = 10 // è¡Œé—´è·
        
        let vc = UICollectionViewController(collectionViewLayout: layout)
        vc.collectionView?.register(NoteCell.self, forCellWithReuseIdentifier: "NoteCell")
        vc.collectionView?.dataSource = context.coordinator
        vc.collectionView?.delegate = context.coordinator
        return vc
    }

    func updateUIViewController(_ uiViewController: UICollectionViewController, context: Context) {
        context.coordinator.items = items
        uiViewController.collectionView?.reloadData()
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, UICollectionViewDataSource, UICollectionViewDelegate, CHTCollectionViewDelegateWaterfallLayout {
        var parent: WaterfallView
        var items: [NoteItem]

        init(_ parent: WaterfallView) {
            self.parent = parent
            self.items = parent.items
        }

        func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
            items.count
        }

        func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "NoteCell", for: indexPath) as! NoteCell
            let item = items[indexPath.item]
            cell.configure(with: item)
            return cell
        }

        // ç€‘å¸ƒæµé«˜åº¦å›è°ƒï¼ˆå¯ç¼“å­˜é«˜åº¦ï¼Œé¿å…é‡å¤è®¡ç®—ï¼‰
        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
            let item = items[indexPath.item]
            // æ ¹æ®æ–‡æœ¬å†…å®¹åŠ¨æ€è®¡ç®—é«˜åº¦ï¼Œå»ºè®®ç¼“å­˜è®¡ç®—ç»“æœ
            let height = calculateHeight(for: item.content)
            return CGSize(width: collectionView.bounds.width / 2 - 10, height: height)
        }

        private func calculateHeight(for text: String) -> CGFloat {
            // ä½¿ç”¨ UILabel æˆ– TextKit è®¡ç®—æ–‡æœ¬é«˜åº¦
            let font = UIFont.systemFont(ofSize: 16)
            let width = collectionView?.bounds.width ?? UIScreen.main.bounds.width
            let constrainedSize = CGSize(width: width / 2 - 20, height: .greatestFiniteMagnitude)
            let boundingBox = text.boundingRect(with: constrainedSize, options: [.usesLineFragmentOrigin, .usesFontLeading], attributes: [.font: font], context: nil)
            return ceil(boundingBox.height) + 40 // åŠ ä¸Špaddingç­‰
        }
    }
}

// è‡ªå®šä¹‰ UICollectionViewCell
class NoteCell: UICollectionViewCell {
    private let label = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        contentView.addSubview(label)
        label.numberOfLines = 0
        label.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            label.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 10),
            label.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 10),
            label.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -10),
            label.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -10)
        ])
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func configure(with item: NoteItem) {
        label.text = item.content
    }
}
```

### 3. åœ¨ SwiftUI ä¸­ä½¿ç”¨
```swift
struct ContentView: View {
    @State private var notes: [NoteItem] = [] // å¤§é‡ç¬”è®°æ•°æ®

    var body: some View {
        WaterfallView(items: notes)
            .onAppear {
                // æ¨¡æ‹ŸåŠ è½½å¤§é‡æ•°æ®
                loadNotes()
            }
    }

    private func loadNotes() {
        // ä»ç½‘ç»œæˆ–æ•°æ®åº“åŠ è½½æ•°æ®ï¼Œæ”¯æŒåˆ†é¡µ
        notes = (0..<1000).map { index in
            NoteItem(content: "è¿™æ˜¯ç¬¬ \(index) æ¡ç¬”è®°ï¼Œå†…å®¹å¾ˆé•¿..." + String(repeating: "æµ‹è¯•æ–‡æœ¬", count: 100))
        }
    }
}

struct NoteItem: Identifiable {
    var id = UUID()
    var content: String
}
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–è¦ç‚¹

### 1. é«˜åº¦ç¼“å­˜
- åœ¨ `Coordinator` ä¸­ç¼“å­˜æ¯ä¸ªcellçš„é«˜åº¦ï¼Œé¿å…æ¯æ¬¡æ»šåŠ¨éƒ½é‡æ–°è®¡ç®—é•¿æ–‡æœ¬é«˜åº¦ã€‚
- å¯ç”¨ `NSCache` æˆ–å­—å…¸ç¼“å­˜ï¼Œkeyä¸ºindexPathæˆ–å†…å®¹hashã€‚

```swift
private var heightCache: [String: CGFloat] = [:]

private func calculateHeight(for text: String) -> CGFloat {
    if let cached = heightCache[text] {
        return cached
    }
    // è®¡ç®—é€»è¾‘...
    heightCache[text] = height
    return height
}
```

### 2. åˆ†é¡µåŠ è½½ï¼ˆPaginationï¼‰
- ç»“åˆ `UICollectionView` çš„é¢„åŠ è½½æœºåˆ¶ï¼Œæ»šåŠ¨åˆ°åº•éƒ¨æ—¶åŠ è½½æ›´å¤šæ•°æ®ï¼Œé¿å…ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰ç¬”è®°ã€‚

```swift
func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let offsetY = scrollView.contentOffset.y
    let contentHeight = scrollView.contentSize.height
    let height = scrollView.frame.size.height

    if offsetY > contentHeight - height {
        // è§¦å‘åŠ è½½æ›´å¤š
        loadMoreNotes()
    }
}
```

### 3. å¼‚æ­¥æ¸²æŸ“
- é•¿æ–‡æœ¬å¸ƒå±€å’Œæ¸²æŸ“æ”¾åˆ°åå°çº¿ç¨‹ï¼Œé¿å…ä¸»çº¿ç¨‹å¡é¡¿ï¼ˆéœ€ç»“åˆTextKitæˆ–AsyncDisplayKitç­‰æ–¹æ¡ˆï¼‰ã€‚

### 4. å‡å°‘è§†å›¾å±‚çº§
- è‡ªå®šä¹‰ `NoteCell` æ—¶å°½é‡ç®€åŒ–è§†å›¾å±‚çº§ï¼Œç”¨çº¯ `UILabel` è€Œéå¤šå±‚åµŒå¥—ã€‚

---

## ğŸš« ä¸æ¨èçº¯SwiftUIæ–¹æ¡ˆçš„åŸå› 

| æ–¹æ¡ˆ                | æ€§èƒ½ç“¶é¢ˆè¯´æ˜                                                                 |
|---------------------|----------------------------------------------------------------------------|
| ç¬¬ä¸‰æ–¹åº“ï¼ˆWaterfallGrid/MasonryStackï¼‰ | æ— è§†å›¾å¤ç”¨ï¼Œå¤§æ•°æ®é‡ä¸‹å†…å­˜å ç”¨é«˜ï¼›é•¿æ–‡æœ¬é«˜åº¦è®¡ç®—é¢‘ç¹ï¼Œæ˜“å¡é¡¿ã€‚               |
| LazyVStack+HStackç»„åˆ | è™½æœ‰æ‡’åŠ è½½ï¼Œä½†ç€‘å¸ƒæµéœ€æ‰‹åŠ¨ç®¡ç†åˆ—é«˜ï¼Œä¸”SwiftUIåœ¨é«˜åº¦è®¡ç®—å’Œå¸ƒå±€æ›´æ–°ä¸Šæ€§èƒ½ä¸å¦‚UICollectionViewã€‚ |
| è‡ªå®šä¹‰Layoutåè®®     | è™½ç„¶çµæ´»ï¼Œä½†éœ€è‡ªè¡Œå®ç°æ‡’åŠ è½½ã€è§†å›¾å¤ç”¨ã€é«˜åº¦ç¼“å­˜ï¼Œå·¥ç¨‹é‡å¤§ï¼Œä¸”ä»ä¸å¦‚UICollectionViewæˆç†Ÿã€‚ |

---

## ğŸ¯ æ€»ç»“

- **æœ€ä½³é€‰æ‹©**ï¼š**UICollectionView + CHTCollectionViewWaterfallLayout + UIViewControllerRepresentable**ï¼Œå…¼é¡¾æ€§èƒ½å’Œæˆç†Ÿåº¦ã€‚
- **ä¼˜åŒ–é‡ç‚¹**ï¼šé«˜åº¦ç¼“å­˜ã€åˆ†é¡µåŠ è½½ã€å¼‚æ­¥æ¸²æŸ“ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼šè¶…å¤§æ•°æ®é‡ï¼ˆä¸Šåƒæ¡ç¬”è®°ï¼‰ã€é•¿æ–‡æœ¬ï¼ˆ1000å­—+ï¼‰ã€é«˜åˆ·æ–°é¢‘ç‡ã€è¦æ±‚æè‡´æ»šåŠ¨æµç•…åº¦ã€‚

å¦‚éœ€å…·ä½“ä»£ç ç¤ºä¾‹ã€åˆ†é¡µåŠ è½½ç»†èŠ‚æˆ–é«˜åº¦ç¼“å­˜å®ç°ï¼Œå¯è¿›ä¸€æ­¥æ·±å…¥æ¢è®¨ï¼