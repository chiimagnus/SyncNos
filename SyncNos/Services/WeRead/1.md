### 概览 obsidian-weread-plugin
本插件将微信读书（WeRead）上的用户笔记（划线/highlight、评论/review、章节信息、阅读进度）同步到 Obsidian Vault 的 Markdown 文件。核心组件与职责如下：
- **认证/Cookie 管理**：扫码登录或通过 CookieCloud 获取 cookie（`src/components/wereadLoginModel.ts`、`src/cookieCloud.ts`、`src/utils/cookiesUtil.ts`）。
- **API 层**：与 weread 接口通讯并做 cookie 刷新逻辑（`src/api.ts`）。
- **解析层**：把接口返回的 JSON 解析成插件内部模型（`src/parser/parseResponse.ts`、`src/models.ts`）。
- **同步与转换逻辑**：以元数据为中心，转换为要写入的 Notebook 结构（`src/syncNotebooks.ts`）。
- **文件写入与渲染**：生成并写入 Markdown，写入 frontmatter 与内容渲染（`src/fileManager.ts`、`src/renderer.ts`）。
- **UI 与配置**：插件入口、设置页与命令绑定（`main.ts`、`src/settingTab.ts`、`src/settings.ts`）。

---

### 核心同步流程（高层步骤）
1. 用户通过插件触发同步（Ribbon 按钮或命令）。
   - 触发函数：`WereadPlugin.startSync()` → 调用 `SyncNotebooks.syncNotebooks()`（见 `main.ts` / `src/syncNotebooks.ts`）。
   ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/main.ts
137:145:main.ts
async startSync(force = false) {
	if (this.syncing) {
		new Notice('正在同步微信读书笔记，请勿重复点击');
		return;
	}
	this.syncing = true;
	try {
		await this.syncNotebooks.syncNotebooks(force, window.moment().format('YYYY-MM-DD'));
```

2. 同步入口 `SyncNotebooks.syncNotebooks()`：
   - 获取所有书的元数据（调用 API 层 `getNotebooksWithRetry`）；
   - 过滤（黑名单、笔记数阈值、本地已有且未更新、公众号是否保存等）；
   - 对需同步的每本书调用 `convertToNotebook()`，收集 highlights、reviews、章节、阅读进度等；
   - 渲染模板并写入/更新 Obsidian 文件。
   ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/syncNotebooks.ts
39:71:src/syncNotebooks.ts
async syncNotebooks(force = false, journalDate: string) {
	new Notice('微信读书笔记同步开始!');
	const syncStartTime = new Date().getTime();
	const metaDataArr = await this.getALlMetadata();
	const filterMetaArr = await this.filterNoteMetas(force, metaDataArr);
	...
	for (const meta of filterMetaArr) {
		const notebook = await this.convertToNotebook(meta);
		await this.saveNotebook(notebook);
```

3. `convertToNotebook()`（逐书构建 Notebook）：
   - 取书籍详情 `apiManager.getBook()`（分类、isbn、简介等）；
   - 获取阅读进度 `getProgress()`；
   - 获取划线 `getNotebookHighlights()`、评论 `getNotebookReviews()`、章节 `getChapters()`；
   - 使用解析器把 API 返回转成内部的 `ChapterHighlightReview[]`、`BookReview` 等数据结构。
   ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/syncNotebooks.ts
79:119:src/syncNotebooks.ts
private async convertToNotebook(metaData: Metadata): Promise<Notebook> {
	const bookDetail = await this.apiManager.getBook(metaData.bookId);
	...
	const highlightResp = await this.apiManager.getNotebookHighlights(metaData.bookId);
	const reviewResp = await this.apiManager.getNotebookReviews(metaData.bookId);
	const chapterResp = await this.apiManager.getChapters(metaData.bookId);
	const highlights = parseHighlights(highlightResp, reviewResp);
	const reviews = parseReviews(reviewResp);
	const chapters = parseChapterResp(chapterResp, highlightResp);
```

4. 渲染与写文件：
   - 使用 `Renderer.render()` 把 Notebook 转为 markdown 内容（基于用户模板，Nunjucks）；
   - 通过 `FileManager.saveNotebook()` 决定是修改现有文件还是创建新文件，并写入 Frontmatter（元数据）和渲染内容。
   ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/fileManager.ts
124:141:src/fileManager.ts
public async saveNotebook(notebook: Notebook): Promise<void> {
	const localFile = notebook.metaData.file;
	if (localFile) {
		if (localFile.new) {
			const existingFile = localFile.file;
			const freshContent = this.renderer.render(notebook);
			const fileContent = buildFrontMatter(freshContent, notebook, existingFile);
			await this.vault.modify(existingFile, fileContent);
		}
	} else {
		const newFilePath = await this.getNewNotebookFilePath(notebook);
		const markdownContent = this.renderer.render(notebook);
		const fileContent = buildFrontMatter(markdownContent, notebook);
		await this.vault.create(newFilePath, fileContent);
	}
}
```

---

### 认证与 Cookie 管理（登录流、CookieCloud）
- 支持两种登录方式：扫码登录（桌面打开内嵌 Electron 窗口监听登录结果）和 CookieCloud（远端托管 cookie）。
  - 扫码登录实现：`src/components/wereadLoginModel.ts`，通过 Electron BrowserWindow 打开微信读书登录页，监听 web 请求头抓取 Cookie（`onSendHeaders`）并写入 settings。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/components/wereadLoginModel.ts
25:47:src/components/wereadLoginModel.ts
const filter = {
	urls: ['https://weread.qq.com/web/user?userVid=*']
};
session.webRequest.onSendHeaders(filter, (details) => {
	const cookies = details.requestHeaders['Cookie'];
	const cookieArr = parseCookies(cookies);
	const wr_name = cookieArr.find((cookie) => cookie.name == 'wr_name').value;
	if (wr_name !== '') {
		settingsStore.actions.setCookies(cookieArr);
		settingTab.display();
		this.modal.close();
	} else {
		this.modal.reload();
	}
});
```
  - CookieCloud 实现：`src/cookieCloud.ts`，从用户配置的服务器拉取加密 cookie JSON，然后解密并更新 settings。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/cookieCloud.ts
8:46:src/cookieCloud.ts
async getCookie() {
	const info = get(settingsStore).cookieCloudInfo;
	...
	const resp = await requestUrl(req);
	...
	if (json && json.encrypted) {
		const { cookie_data } = this.cookieDecrypt(info.uuid, json.encrypted, info.password);
		for (const key in cookie_data) {
			const cookieStr = [...]
			return this.updateCookies(cookieStr);
		}
	}
}
```
  - 解密逻辑使用 `crypto-js`：`cookieDecrypt()` 用 `MD5(uuid+'-'+password)` 截取 16 字节做 AES key，随后 AES 解密。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/cookieCloud.ts
58:71:src/cookieCloud.ts
private cookieDecrypt(uuid: string, encrypted: string, password: string) {
	const the_key = CryptoJS.MD5(uuid + '-' + password)
		.toString()
		.substring(0, 16);
	const decrypted = CryptoJS.AES.decrypt(encrypted, the_key).toString(CryptoJS.enc.Utf8);
	const parsed = JSON.parse(decrypted);
	return parsed;
}
```
- Cookie 解析与拼接工具位于 `src/utils/cookiesUtil.ts`：
  - `parseCookies()` 把 `k1=v1; k2=v2` 解析成数组对象；
  - `getCookieString()` 把 cookie 列表拼成请求头需要的字符串（用于 `ApiManager.getHeaders()`）。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/utils/cookiesUtil.ts
5:18:src/utils/cookiesUtil.ts
export const parseCookies = (cookieInput: string): Cookie[] => {
	...
};
export const getCookieString = (cookies: Cookie[]): string => {
	return cookies.map(...).join(';');
};
```

---

### API 层：请求、错误处理与 Cookie 刷新
- 所有对 weread 的 HTTP 请求都在 `src/api.ts` 的 `ApiManager` 中封装；`getHeaders()` 会把 `settingsStore` 中的 cookie 拼接进请求头：
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/api.ts
18:27:src/api.ts
private getHeaders() {
	return {
		'User-Agent': 'Mozilla/5.0 ...',
		'Accept-Encoding': 'gzip, deflate, br',
		accept: 'application/json, text/plain, */*',
		'Content-Type': 'application/json',
		Cookie: getCookieString(get(settingsStore).cookies)
	};
}
```
- 401 / 登录超时的处理：
  - 在 `getNotebooks()` 和其他方法中，一旦接口返回登录过期（errcode -2012 或 401），会尝试 `refreshCookie()`：先发一个 `HEAD https://weread.qq.com` 来刷新 Cookie（可能由 weread 返回 `Set-Cookie`），并调用 `updateCookies()` 更新到 `settingsStore`；若失败且使用 CookieCloud，则会调用 CookieCloudManager 重新获取 cookie。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/api.ts
30:54:src/api.ts
async refreshCookie() {
	const req: RequestUrlParam = {
		url: this.baseUrl,
		method: 'HEAD',
		headers: this.getHeaders()
	};
	const resp = await requestUrl(req);
	const respCookie: string = resp.headers['set-cookie'] || resp.headers['Set-Cookie'];
	if (respCookie !== undefined && this.checkCookies(respCookie)) {
		new Notice('cookie已过期，尝试刷新Cookie成功');
		this.updateCookies(respCookie);
	} else {
		...
	}
}
```
- `checkCookies()` / `updateCookies()`：解析 `Set-Cookie` 返回，替换本地 cookies 中的值（只替换同名 cookie 的 value），并写入 `settingsStore.actions.setCookies()`。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/api.ts
268:297:src/api.ts
private checkCookies(respCookie: string): boolean { ... }
private updateCookies(respCookie: string) { ... }
```

---

### 数据模型（内部表示）
- `src/models.ts` 定义插件内部的类型：`Metadata`（书的元信息）、`Highlight`、`Review`、`ChapterHighlightReview`、`Notebook` 等，解析器会把 API 的复杂 JSON 映射到这些类型，以便模板渲染和文件写入。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/models.ts
323:361:src/models.ts
export type Metadata = {
	bookId: string;
	author: string;
	title: string;
	...
};
```

---

### 解析层：如何把 API 返回转为内部结构
- 解析主要在 `src/parser/parseResponse.ts` 中完成（函数例如 `parseMetadata`、`parseHighlights`、`parseReviews`、`parseChapterResp`、`parseChapterHighlightReview` 等）。
  - `parseMetadata()`：把 `getNotebooks()` 返回的每个条目转成 `Metadata`（包含 `bookId`、`noteCount`、`lastReadDate`、`pcUrl` 等）。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/parser/parseResponse.ts
21:41:src/parser/parseResponse.ts
export const parseMetadata = (noteBook: any): Metadata => {
	const book = noteBook['book'];
	const cover: string = book['cover'].replace('/s_', '/t7_');
	const lastReadDate = window.moment(noteBook['sort'] * 1000).format('YYYY-MM-DD');
	...
	return metaData;
};
```
  - `parseHighlights()`：将 highlights 列表映射成 `Highlight`，并查找对应的 review（若存在）合并为 `reviewContent`，规范化 `bookmarkId` 等字段。
  - `parseChapterResp()`：从章节接口或 highlight 的 refMpInfos 构建 chapter 列表（兼容公众号文章）。
  - `parseChapterHighlightReview()` / `parseArticleHighlightReview()`：把章节与 highlight、review 组合起来，排序并生成 `ChapterHighlightReview[]`。

---

### 本地文件策略（命名、去重、DailyNotes）
- 本地按 `settings` 中配置存放路径、文件名规则（几种可选策略），并支持子文件夹按书名或分类分组；若文件已存在则比较 `noteCount` 和 `reviewCount` 决定是否需要更新（`FileManager.getNotebookFiles()` 与 `SyncNotebooks.getLocalNotebookFile()`）。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/fileManager.ts
182:192:src/fileManager.ts
private getNewNotebookFilePath(notebook: Notebook): Promise<string> {
	const folderPath = `${get(settingsStore).noteLocation}/${this.getSubFolderPath(notebook.metaData)}`;
	...
	const fileName = this.getFileName(notebook.metaData);
	const filePath = `${folderPath}/${fileName}.md`;
	return filePath;
}
```
- 支持把当天的 highlights 写入 Daily Notes 的指定区间（使用 `insertAfter` / `insertBefore` 来定位并覆盖区间），通过 `parseDailyNoteReferences()` 生成引用块并写入 `saveDailyNotes()`。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/syncNotebooks.ts
164:183:src/syncNotebooks.ts
if (get(settingsStore).dailyNotesToggle) {
	const dailyNoteRefereneces = parseDailyNoteReferences(notebooksInDate);
	const dailyNotePath = this.fileManager.getDailyNotePath(window.moment());
	this.fileManager.saveDailyNotes(dailyNotePath, dailyNoteRefereneces);
}
```

---

### 模板渲染（用户自定义）与 HTML→Markdown 转换
- 使用 Nunjucks 渲染用户自定义模板（在设置中可编辑），Renderer 在 `src/renderer.ts` 中实现，提供 `replace` 过滤器并禁用 autoescape。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/renderer.ts
5:15:src/renderer.ts
constructor() {
	nunjucks.configure({ autoescape: false }).addFilter('replace', function (str, pattern, replacement) {
		...
	});
}
```
- 评论的 HTML 内容（若包含 `htmlContent`）使用 `node-html-markdown` 在解析时转为 Markdown（`parseReviews()` 内部使用）。

---

### 错误处理与重试策略
- 对关键 API（如 `getNotebooks`）做了重试逻辑：第一次失败会再尝试一次，若依然失败并发现 cookie 过期，则调用 `refreshCookie()` 并在必要时清理并提示用户重新登录。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/api.ts
56:68:src/api.ts
async getNotebooksWithRetry() {
	let noteBookResp: [] = await this.getNotebooks();
	if (noteBookResp === undefined || noteBookResp.length === 0) {
		noteBookResp = await this.getNotebooks();
	}
	if (noteBookResp === undefined || noteBookResp.length === 0) {
		new Notice('长时间未登录，Cookie已失效，请重新扫码登录！');
		settingsStore.actions.clearCookies();
		throw Error('get weread note book error after retry');
	}
	return noteBookResp;
}
```
- 当 API 明确返回登录超时（errcode -2012）或 HTTP 401，会触发 cookie 刷新或 CookieCloud 重新获取逻辑，并在 UI 层给出 Notice 提示。

---

### 与 Obsidian 的集成点（命令、菜单、文件系统）
- 插件在 `main.ts` 注册命令、Ribbon 菜单和 editor context menu（右键当前 note 时提供“同步当前读书笔记”）。
- 使用 Obsidian 的 `Vault` API 进行文件读写（`vault.create`、`vault.modify`），并使用 `metadataCache` 读取 frontmatter 以识别已有的 weread 笔记（`FileManager.getWereadNoteAnnotationFile()`）。
  ```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/fileManager.ts
143:161:src/fileManager.ts
public getWereadNoteAnnotationFile = (file: TFile): AnnotationFile | null => {
	const cache = this.metadataCache.getFileCache(file);
	const frontmatter = cache?.frontmatter;
	if (frontmatter?.['doc_type'] === frontMatterDocType && frontmatter?.['bookId'] !== undefined) {
		return {
			file,
			bookId: frontmatter['bookId'],
			reviewCount: frontmatter['reviewCount'],
			noteCount: frontmatter['noteCount'],
			new: false
		};
	}
	return null;
};
```

---

### 关键文件与主要函数索引（便于阅读源码）
- `main.ts`：插件入口，注册命令与 UI（Ribbon、context menu）并触发同步。
- `src/api.ts`：ApiManager（请求、cookie 刷新、getBook/getProgress/getNotebookHighlights/getNotebookReviews/getChapters 等）。
  - 重要：`getHeaders()`、`refreshCookie()`、`getNotebooks()`、`updateCookies()`。
- `src/syncNotebooks.ts`：核心同步协调逻辑（`syncNotebooks()`、`convertToNotebook()`、`filterNoteMetas()`）。
- `src/parser/parseResponse.ts`：解析 API JSON → 内部类型（`parseMetadata`、`parseHighlights`、`parseReviews`、`parseChapterResp`、`parseChapterHighlightReview`、`parseDailyNoteReferences`）。
- `src/fileManager.ts`：文件写入与 Daily Notes 插入（`saveNotebook()`、`getNotebookFiles()`、`saveDailyNotes()`、`getNewNotebookFilePath()`）。
- `src/cookieCloud.ts`：CookieCloud 支持（远程拉取 & AES 解密）。
- `src/utils/cookiesUtil.ts`：cookie 字符串解析/拼装，辅助函数 `getCookieString()`。
- `src/renderer.ts`：Nunjucks 渲染。
- `src/settings.ts`：settings store 与操作接口（`setCookies()`、`clearCookies()`、`initialise()` 等）。

---

### 可改进 / 注意事项（从代码角度的建议）
- Cookie 的安全性：CookieCloud 解密使用 MD5(uuid+ '-' + password) 截 16 字节作 key，MD5 已不够强，若安全性要求高建议改用更强健的 HMAC/KDF（这会牵涉到兼容性）。
- 错误重试与并发：当前同步是按书顺序串行处理，若数据量大可以考虑并发获取书详情/章节（注意被 API 限制与 cookie 刷新竞态）。
- 日志与可观察性：增加更细粒度的日志级别与 telemetry 以便诊断大量书时的性能点。
- 单元测试：解析器函数是纯函数，易于单测，建议补充测试覆盖 `parseHighlights`/`parseReviews` 等逻辑。

---

### 结语
- **总体设计**：插件采用清晰的分层设计（认证 → API → 解析 → 转换 → 渲染 → 写入）。认证能自动刷新或从 CookieCloud 拉取。解析器将 weread 的复杂 JSON 映射为插件内部模型，最后用 Nunjucks 渲染用户模板并写入 Obsidian 文件。
- 若你需要，我可以：
  - 进一步生成一个类图或时序图（同步流程）；
  - 或者为关键函数写一份更详细的注释/README（便于贡献者理解）；
  - 亦可把解析器的每个分支（公众号文章 vs 正常图书）逐行解释并写成测试用例。

- 如需我马上生成时序图或额外的文档（或以 README.md 文件形式写入仓库），回复告诉我你的首选（例如“生成时序图”或“把文档保存为 docs/weread-sync.md”）。

### 示例输出（同步后 Markdown 示例）
下面给出一个同步后生成的 Markdown 文件示例，包含 frontmatter（元数据）与正文渲染结果，便于用户快速验证：

```markdown
---
doc_type: weread
bookId: 26785321
title: 示例书名
author: 作者名
noteCount: 12
reviewCount: 3
lastReadDate: 2025-10-04
readingProgress: 0.45
readingTime: 3600
---

# 示例书名 — 作者名

## 章节 1：绪论
- **划线**：这是书中的重点句子（创建时间: 2025-10-04 10:12:00）

> 评论：这是我为该划线写的评论或笔记

## 章节 2：方法
- **划线**：第二个重点句子（创建时间: 2025-10-04 12:00:00）

---

*（由 weread-obisidian 插件生成）*
```


### 快速开始（最小配置）
- 步骤 1：安装插件并重启 Obsidian。
- 步骤 2：打开设置页（Settings → 插件 → WeRead），选择登录方式：扫码登录（桌面）或 CookieCloud。
- 步骤 3：若选择扫码登录，点击“登录”按钮，完成扫码后返回设置页应显示已登录的用户名；若选择 CookieCloud，填写服务器信息并点“确定”拉取 cookie。
- 步骤 4：在 Obsidian 左侧 Ribbon 点击“同步微信读书笔记”开始同步。首次同步会在指定笔记目录创建 Markdown 文件。


### 主要 cURL 请求示例（便于调试）
下面列出插件常用的 weread 接口请求示例（这些请求是插件内部使用的，展示用于调试）：

- 获取用户书架/笔记元信息（等同于插件内部的 `getNotebooks`）

```bash
curl -X GET 'https://weread.qq.com/api/user/notebook' \
  -H 'Cookie: wr_name=YOUR_USERNAME; wr_vid=YOUR_WRVID; ...' \
  -H 'Accept: application/json'
```

- 获取书籍详情（`getBook`）

```bash
curl -X GET 'https://weread.qq.com/web/book/info?bookId=26785321' \
  -H 'Cookie: ...' -H 'Accept: application/json'
```

- 获取划线（`getNotebookHighlights`）

```bash
curl -X GET 'https://weread.qq.com/web/book/bookmarklist?bookId=26785321' \
  -H 'Cookie: ...' -H 'Accept: application/json'
```

- 获取评论（`getNotebookReviews`）

```bash
curl -X GET 'https://weread.qq.com/web/review/list?bookId=26785321&listType=11&mine=1&synckey=0' \
  -H 'Cookie: ...' -H 'Accept: application/json'
```

- 获取阅读进度（`getProgress`）

```bash
curl -X GET 'https://weread.qq.com/web/book/getProgress?bookId=26785321' \
  -H 'Cookie: ...' -H 'Accept: application/json'
```


### 登录与 Cookie 排错（常见场景与解决办法）
- 问题：在设置页仍显示“未登录”或接口返回 `errcode` 为 `-2012`。 
  - 原因：cookie 过期或不完整（缺少 `wr_name` / `wr_vid` / `wr_skey` 等关键字段）。
  - 解决：
    - 使用扫码登录重新登录；
    - 或在 CookieCloud 配置正确后，手动点击“确定”从 CookieCloud 拉取 cookie；
    - 在必要时，打开浏览器访问 `https://weread.qq.com`，在开发者工具中查看 network 请求的 `Set-Cookie`。

- 问题：CookieCloud 拉取后仍提示失败。
  - 检查：CookieCloud 服务的返回是否包含 `encrypted` 字段，且 `uuid`/`password` 是否正确。
  - 如果解密失败，插件会弹窗提示“解密失败，请检查配置”。


### 安全 & 隐私说明
- 插件会将用户的 weread 登录 cookie 保存在 Obsidian 的插件设置数据中（由 Obsidian 管理），这意味着任何可以访问 Obsidian 配置文件的人都可能读取这些 cookie。请只在可信环境中使用该插件。
- CookieCloud 的端到端加密：插件使用 `crypto-js` 用 `MD5(uuid + '-' + password).substring(0,16)` 作为 AES 密钥对密文解密。MD5 已被认为不够安全，若使用公共 CookieCloud 服务请谨慎。

```startLine:endLine:Users/chii_magnus/Documents/GitHub/obsidian-weread-plugin/src/cookieCloud.ts
58:71:src/cookieCloud.ts
private cookieDecrypt(uuid: string, encrypted: string, password: string) {
	const the_key = CryptoJS.MD5(uuid + '-' + password)
		.toString()
		.substring(0, 16);
	...
}
```


### 调试与查看日志
- 在桌面端，使用 `CMD+OPTION+I`（macOS）或 `CTRL+SHIFT+I`（Windows/Linux）打开开发者工具查看控制台日志。
- 设置页也会在右侧显示调试提示，关键操作处有 `Notice` 提示（例如 cookie 刷新成功/失败、同步完成等）。


### 模板示例与速查
- 插件使用 Nunjucks 渲染模板，支持自定义过滤器 `replace`。以下是一个简短模板示例：

```njk
# {{ metaData.title }} - {{ metaData.author }}

{% for chapter in chapterHighlights %}
## {{ chapter.chapterTitle }}
{% for h in chapter.highlights %}
- {{ h.markText }}
  {% if h.reviewContent %}
  > {{ h.reviewContent }}
  {% endif %}
{% endfor %}
{% endfor %}
```


### 性能建议
- 当前同步采用串行方式逐本书同步；如果你有大量书籍（数百本），同步可能耗时较长。可以考虑对 `convertToNotebook()` 中的网络请求（获取详情、高亮、章节、评论）做并发请求，推荐使用有限并发池（比如同时 5~10 个并发）以避免被远端接口限流或触发验证码/风控。


### 建议的单元测试（开发者）
- `parseHighlights`：包含有/无 `review` 的高亮样例；
- `parseReviews`：HTML 内容转为 Markdown；
- `parseChapterResp`：测试图书与公众号两种分支。
