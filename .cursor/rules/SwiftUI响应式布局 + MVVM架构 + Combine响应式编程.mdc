---
alwaysApply: true
---

# 最佳实践指南：SwiftUI响应式布局 + MVVM架构 + Combine响应式编程

## 项目架构要求

### 核心技术栈
- **架构模式**: MVVM (Model-View-ViewModel)
- **UI框架**: SwiftUI (iOS17+, iPadOS17+, macOS14+)
- **响应式编程**: Combine
- **数据持久化**: SwiftData
- **语言版本**: Swift 6.1+

### 平台支持
- iOS 17.0+
- iPadOS 17.0+
- macOS 14.0+

## MVVM架构规范

### 1. Models (数据模型)
- 纯数据结构，不包含业务逻辑
- 使用 `@Model` 宏用于 SwiftData
- 只包含属性和简单的数据处理方法
- 不直接引用 SwiftUI 或 Combine
- 数据结构应该清晰、简洁

### 2. ViewModels (视图模型)
- 处理业务逻辑，管理状态
- 使用 `@Observable` 宏 (iOS17+/macOS14+) 或 `@ObservableObject`
- 包含 `@Published` 属性用于状态管理
- 不直接引用 SwiftUI Views
- **禁止使用单例模式** (`shared` 静态实例)
- 使用 Combine 进行响应式数据流处理
- 状态管理与UI逻辑，处理用户交互
- 数据绑定，向View提供格式化数据
- 调用Service执行业务操作，订阅数据变化（Combine）
- 错误与加载状态统一处理

#### ViewModel响应式编程规范
- **必须使用@Published**: 所有需要触发UI更新的属性都必须标记为`@Published`
- **计算属性响应式**: 依赖`@Published`属性的计算属性会自动响应变化
- **Combine订阅**: 使用`$property.sink`或`@Published`属性的组合来处理复杂数据流
- **避免手动通知**: 不要手动调用`objectWillChange.send()`，依赖`@Published`自动机制
- 使用 Combine 操作符 (map, filter, debounce, etc.) 处理复杂数据流
- 使用 `Set<AnyCancellable>` 管理订阅生命周期

### 3. Views (视图)
- 纯UI展示，不包含业务逻辑
- SwiftUI开发，@ObservedObject/@StateObject绑定ViewModel
- 通过 `@State` 和 `@Bindable` 管理状态
- 组件化、可复用、条件渲染（加载/错误/空数据）
- iOS设备适配（iPhone/iPad）、暗黑模式、主题切换
- 响应式布局，支持不同屏幕尺寸
- 使用 ScrollView 优化长内容展示

## 代码组织与职责分离

### 文件结构
```
Feature/
├── Views/
│   ├── FeatureView.swift
│   └── Components/
├── ViewModels/
│   └── FeatureViewModel.swift
├── Models/
│   └── FeatureModel.swift
└── Services/
    └── FeatureService.swift
```

### 职责分离原则
- **Views**: 只负责UI展示和用户交互响应
- **ViewModels**: 处理业务逻辑、数据转换、状态管理
- **Models**: 数据结构定义和简单数据处理
- **Services**: 网络请求、数据存储等基础设施逻辑

## ViewModel 实例化策略

### 推荐方式
1. **按需创建**：每个视图创建独立的ViewModel实例
2. **依赖注入**：通过 `.environment()` 传递ViewModel
3. **生命周期管理**：
   - 短期：使用 `@State` 管理
   - 长期：使用 `@Environment` 或 `@StateObject`

### 禁止方式
- ❌ 使用 `static let shared` 单例模式
- ❌ 在ViewModel中创建全局状态
- ❌ 多个视图共享同一个ViewModel实例

### 正确示例
```swift
// ✅ 正确：按需创建
@State private var viewModel = ItemViewModel()

// ✅ 正确：依赖注入
.environment(ItemViewModel())

// ✅ 正确：响应式ViewModel
@Observable
class ItemViewModel {
    @Published var items: [Item] = []
    @Published var filteredItems: [DisplayItem] = []
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        $items
            .map { items in
                items.map { DisplayItem(from: $0) }
            }
            .assign(to: &$filteredItems)
    }
}
```

## SwiftUI最佳实践

### 响应式布局
- 优先使用 SwiftUI 内置的响应式布局系统
- 合理使用 Size Classes 进行设备适配
- 避免过度使用 GeometryReader
- 使用 ScrollView 优化长内容展示

### 状态管理
```swift
// ✅ 正确：按需创建ViewModel
struct FeatureView: View {
    @State private var viewModel = FeatureViewModel()
    
    var body: some View {
        ContentView()
            .environment(viewModel)
    }
}

// ✅ 正确：响应式ViewModel
@Observable
class FeatureViewModel {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        $items
            .map { items in
                items.map { transformItem($0) }
            }
            .sink { [weak self] transformedItems in
                // 处理转换后的数据
            }
            .store(in: &cancellables)
    }
}
```

### 组件化开发
- 每个组件职责单一
- 组件可复用、可测试
- 合理使用 ViewModifier 和 ViewBuilder
- 避免过深层次的视图嵌套

## Combine响应式编程

### 数据流处理
```swift
// ViewModel中的响应式数据处理
class MyViewModel: ObservableObject {
    @Published var sourceData: [DataModel] = []
    @Published var processedData: [DisplayModel] = []
    @Published var searchText = ""
    @Published var searchResults: [Item] = []
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        // 响应式数据转换
        $sourceData
            .map { data in
                // 业务逻辑处理
                return data.map { DisplayModel(from: $0) }
            }
            .assign(to: &$processedData)
            
        // 搜索功能
        $searchText
            .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
            .removeDuplicates()
            .flatMap { text in
                text.isEmpty ? Just([]).eraseToAnyPublisher() : 
                self.searchService.search(text).catch { _ in Just([]) }.eraseToAnyPublisher()
            }
            .assign(to: &$searchResults)
    }
}

### 响应式编程最佳实践
1. **数据源响应**: 使用`@Published`属性作为数据源
2. **自动转换**: 通过`.map`、`.filter`等操作符处理数据
3. **链式操作**: 使用`.assign(to:)`或`.sink`订阅结果
4. **内存管理**: 使用`Set<AnyCancellable>`管理订阅生命周期
5. **错误处理**: 使用`.catch`、`.replaceError`处理错误情况
```

### 错误处理
- 使用 `catch` 操作符处理错误
- 统一错误处理机制
- 避免在 View 层处理复杂错误逻辑

## 禁止事项

### 架构层面
- ❌ 在 View 中直接处理业务逻辑
- ❌ 在 Model 中包含业务逻辑
- ❌ 使用单例模式创建 ViewModel
- ❌ 多个 View 共享同一个 ViewModel 实例
- ❌ 在 ViewModel 中直接操作 UI
- ❌ 在View中直接访问数据库

### 代码实现
- ❌ 手动计算屏幕尺寸和比例
- ❌ 使用固定像素值布局
- ❌ 复杂的 GeometryReader 嵌套
- ❌ 忽略内存管理 (忘记调用 store(in:))
- ❌ 在View中直接处理业务逻辑
- ❌ 在Model中包含业务逻辑
- ❌ 在ViewModel中直接操作UI
- ❌ 在View中直接访问数据库

## 性能优化

### 响应式数据流
- 合理使用 `@Published` 避免不必要的更新
- 使用 `removeDuplicates()` 减少重复计算
- 使用 `debounce()` 优化用户输入响应

### 视图渲染
- 避免在 `body` 中进行复杂计算
- 使用 `@State` 和 `@Binding` 优化状态传递
- 合理使用 `@ViewBuilder` 优化视图构建

## 测试与维护

### 可测试性
- ViewModel 应该易于单元测试
- 业务逻辑与 UI 逻辑分离
- 使用依赖注入便于测试

### 代码质量
- 遵循 Swift 命名规范
- 保持函数和类的职责单一
- 添加必要的注释和文档
- 代码规范、类型安全、健壮性、详细注释
- **在增加函数func前先看看其他文件是否已有相关实现**
- 遵循Apple HIG，界面直观易用，专注iOS体验

## 技术栈

### 核心技术
- **SwiftUI**：iOS UI开发
- **Combine**：响应式数据流
- **SwiftData**：本地数据持久化
- **URLSession**：网络通信
- **PhotosUI**：系统照片选择器
- **AVFoundation**：媒体处理
- **CoreGraphics**：图像处理

## 参考资料

- [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines)
- [SwiftUI 官方文档](https://developer.apple.com/documentation/swiftui)
- [Combine 官方文档](https://developer.apple.com/documentation/combine)
- [SwiftData 官方文档](https://developer.apple.com/documentation/swiftdata)
- [PhotosUI 官方文档](https://developer.apple.com/documentation/photosui)
- [AVFoundation 官方文档](https://developer.apple.com/documentation/avfoundation)
- [URLSession 官方文档](https://developer.apple.com/documentation/foundation/urlsession)